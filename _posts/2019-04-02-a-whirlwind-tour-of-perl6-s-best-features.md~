---
layout: post
title: A Whirlwind Tour of Perl6's Best Features
date: 2019-04-02 17:31 -0700
---
It's rare that I find a language that I truly feel innovates upon established conventions and features. Perl6 came out in late 2015 to little fanfare -- it was written off by the Perl community as unnecessary change and by the larger programming community as, well, still Perl. I feel that Perl6 fills the same niche that Lisp does: there are a hundred short and elegant ways to do the same thing, and it's up to the programmer to decide which one works best for them. It's extensible and customizable so therefore [it'll last a long time](https://aearnus.github.io/2018/07/09/programming-language-diversity). 

In the spirit of Perl, Perl6 is extremely terse and can be fairly hard to read. There's a lot that goes on behind the scenes that you would hardly catch if you weren't acquainted with the language. To get up to speed, I found the [Learn X in Y minutes page for Perl6](https://learnxinyminutes.com/docs/perl6/) _extremely_ helpful. Before continuing, you should skim through that page. 

I've only been writing Perl6 for a couple of days, so please excuse any errors & message me using the links at the bottom or the discord at the top so I could correct them.

These first few features all relate to powerful ways to express functions unique to Perl6.

# Writing Functions

## The Whatever Star

(yes, that's its real name.)

The whatever star inhereits its namesake from the wildcard character, which gets replaced by "whatever" when evaluated by your shell. In Perl6, the whatever star creates an implicit block which can be used in place of anything that expects a `Callable`. This process is called _whatever-currying_. Here are the docs: [https://docs.perl6.org/type/WhateverCode].

This is useful for a wide variety of reasons. Here's an example I feel is relatively succinct: 

```perl6
1,1,*+* ...^ * >= 100
```

I won't delve too deeply into breaking this down, but this is a list representing every fibonacci number less than 100. `...^` is the [sequence operator](https://docs.perl6.org/language/operators#index-entry-sequence_operator) which takes a list on its left side ending with a generator function and an ending condition on the right side. Once the number generated by the generator function smart matches against the ending condition, the list is complete. You can also pass a whatever star in the right side of `...^` to create an infinite lazy list. To do something like this in another language, you'd have to pass a bogus parameter or call a function dedicated to constructing a list of this type. But, the whatever star allows the programer to explicitly write out cases of this form where arguments are unneeded or special functionality is required.

## Implicit Chaining

There is a special variable in Perl6 named `$_`. It has type `(Any)` and essentially takes on whatever value that would make sense in the moment. In for loops it becomes the looping parameter, and in blocks of code it becomes the implicit parameter. It can be set explicitly using `given` constructs (but more on that later). A special feature of Perl6's syntax is that the `.` operator implicity calls functions on `$_` if a left operand isn't passed into it. Along with implicit return statements, this encourages a rather elegant form of method chaining -- akin to Ruby's [tap](https://ruby-doc.org/core-2.6.2/Object.html#method-i-tap) or [pointfree style Haskell](https://wiki.haskell.org/Pointfree).

Here's a contrived example: given a list of lists, filter the lists down to only their even elements and print the new lists.

```perl6
> (1..2 X 1..2).map: { .grep(!(* % 2)).say }
()
(2)
(2)
(2 2)
```

The significant code here is `{ .grep(!(* % 2)).say }`. This is a block that takes an implicit argument (passed in as `$_`), filters out eveything that isn't divisible by 2 (`.grep(!(* % 2))`), and prints it to standard output. We can use this block as a standalone callable to see this in action:

```perl6
> { .grep(!(* % 2)).say }(1..10)
(2 4 6 8 10)
```

In my opinion, this opens the opportunity 

## Redefinable Operators


